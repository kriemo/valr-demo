[
["index.html", "valr demonstrations Chapter 1 Introduction 1.1 Installation 1.2 Contribute 1.3 Comparison to other tools", " valr demonstrations Jay Hesselberth 2016-09-12 Chapter 1 Introduction valr provides tools to read and manipulate genome intervals and signals, similar to the standalone BEDtools suite. valr enables BEDtools-like analysis in the R/RStudio environment, and uses modern R tools for a terse, expressive syntax. Compute-intensive algorithms are implemented in Rcpp/C++, and many methods take advantage of the speed and grouping capability provided by dplyr. We provide several introductions to valr: This comprehensive vignette that covers the core methods. A tutorial that demonstrates how to use valr in “real-world” applications. A shiny application that demonstrates interactive analysis of genome-scale data sets. library(valr) library(dplyr) 1.1 Installation valr can be installed from github, and will be eventually deposited in CRAN. devtools::install_github(&#39;jayhesselberth/valr&#39;) 1.2 Contribute valr is actively maintained on [github][http://github.com/jayhesselberth/valr] and we welcome ideas for new tools and pull requests. 1.3 Comparison to other tools Why another tool set for interval manipulations? We already have BEDtools, bedops, pybedtools, GenomeRanges, bedr and IRanges. We were motivated to develop a toolset that: Combines analysis and visualization in RStudio. Can be used to generate reports with Rmarkdown. Is highly extensible. New tools are quickly implemented on the R side. Leverages the “modern R” syntax, using dplyr and the pipe operator from magrittr (%&gt;%). Maximizes speed by implementing compute-intensive algorithms in Rcpp. Facilitates interactive visulaizations with shiny. We anticipate valr will mainly be used for analysis of pre-processed data in BED, bedGraph and VCF formats. Most users will have processed their aligned reads from BAM format to bedGraph, so we do not foresee supporting BAM directly. We would entertain requests for GTF / GFF support if there is interest, as tidyr makes it easy to convert these to BED12. Certain algorithms in valr were implemented in Rcpp (including intersect, merge, subtract, closest) to enable fluid interactive analysis. See the benchmarks section for details. "],
["functions.html", "Chapter 2 Functions 2.1 Non-standard evaluation 2.2 Reading data 2.3 Interval manipulations", " Chapter 2 Functions 2.1 Non-standard evaluation Several of the methods in valr use non-standard evaluation (NSE) for an expressive syntax. Columns are referred to as naked, unquoted names and can be used in multiple name/value expressions. bed_map(x, y, mean = mean(value), var = var(value)) bed_merge(x, concat = concat(value), max = max(value)) valr has a variety of functions for reading and manipulating intervals. 2.2 Reading data valr has several methods to read interval data. These methods: Take local files or URLs as input. Return a data.frame in tibble::tbl_df format. Assign consistent chrom, start and end column names. Use readr for speed. Coerce column types. The methods include: read_bed(): read a BED3+ file read_bed12(): read a BED12 file read_bedgraph(): read a bedGraph file read_genome(): read a UCSC “chrom size” file read_vcf(): read the Variant Call Format read_narrowpeak(): read narrowPeak files read_broadpeak(): read broadPeak files 2.2.1 BED files read_bed(system.file(&#39;extdata&#39;, &#39;3fields.bed.gz&#39;, package = &#39;valr&#39;)) #&gt; # A tibble: 10 × 3 #&gt; chrom start end #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 chr1 11873 14409 #&gt; 2 chr1 14361 19759 #&gt; 3 chr1 14406 29370 #&gt; 4 chr1 34610 36081 #&gt; 5 chr1 69090 70008 #&gt; 6 chr1 134772 140566 #&gt; # ... with 4 more rows read_bed(n_fields = 6, system.file(&#39;extdata&#39;, &#39;6fields.bed.gz&#39;, package = &#39;valr&#39;)) #&gt; # A tibble: 10 × 6 #&gt; chrom start end name score strand #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 chr1 11873 14409 DDX11L1 3 + #&gt; 2 chr1 14361 19759 WASH7P 10 - #&gt; 3 chr1 14406 29370 WASH7P 7 - #&gt; 4 chr1 34610 36081 FAM138F 3 - #&gt; 5 chr1 69090 70008 OR4F5 1 + #&gt; 6 chr1 134772 140566 LOC729737 3 - #&gt; # ... with 4 more rows read_bed12(system.file(&#39;extdata&#39;, &#39;12fields.bed.gz&#39;, package = &#39;valr&#39;)) #&gt; # A tibble: 3 × 12 #&gt; chrom start end name score strand cds_start cds_end item_rgb #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 chr1 4797973 4836816 testgene 1 + 4797973 4836816 . #&gt; 2 chr10 4848118 4880877 diffchrom 1 + 4848118 4880877 . #&gt; 3 chr20 5073253 5152630 negstrand 1 - 5073253 5152630 . #&gt; # ... with 3 more variables: exon_count &lt;int&gt;, exon_sizes &lt;chr&gt;, #&gt; # exon_starts &lt;chr&gt; 2.2.2 Genome files genome &lt;- read_genome(system.file(&#39;extdata&#39;, &#39;hg19.chrom.sizes.gz&#39;, package = &#39;valr&#39;)) 2.2.3 bedGraph files read_bedgraph(system.file(&#39;extdata&#39;, &#39;test.bg.gz&#39;, package = &#39;valr&#39;)) #&gt; # A tibble: 4 × 4 #&gt; chrom start end value #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 chr19 49302000 49302300 -1.00 #&gt; 2 chr19 49302300 49302600 -0.75 #&gt; 3 chr19 49302600 49302900 -0.50 #&gt; 4 chr19 49302900 49303200 -0.25 2.2.4 VCF files read_vcf() reads VCF files and assigns chrom, start and end columns to be used to downstream interval comparisons. Note the interval size is calculated as the length of the REF field in the original file. read_vcf(system.file(&#39;extdata&#39;, &#39;test.vcf.gz&#39;, package = &#39;valr&#39;)) #&gt; # A tibble: 115 × 201 #&gt; CHROM POS ID REF ALT #&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 10172 . CCCTAA C #&gt; 2 1 10390 . CCCCTAACCCCTAACCCTAACCCTAACCCTAACCCTAACCCTAA C #&gt; 3 1 10397 . CCCCTAACCCTAA C #&gt; 4 1 10403 . ACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAAC A #&gt; 5 1 10409 . ACCCTAACCCTAACCCTAACCCTAACCCTAAC A #&gt; 6 1 10415 . ACCCTAACCCTAACCCTAACCCTAAC A #&gt; # ... with 109 more rows, and 196 more variables: QUAL &lt;dbl&gt;, #&gt; # FILTER &lt;chr&gt;, INFO &lt;chr&gt;, FORMAT &lt;chr&gt;, `101976-101976` &lt;chr&gt;, #&gt; # `100920-100920` &lt;chr&gt;, `100231-100231` &lt;chr&gt;, `100232-100232` &lt;chr&gt;, #&gt; # `100919-100919` &lt;chr&gt;, `101977-101977` &lt;chr&gt;, `100630-100630` &lt;chr&gt;, #&gt; # `100640-100640` &lt;chr&gt;, `100631-100631` &lt;chr&gt;, `101583-101583` &lt;chr&gt;, #&gt; # `101584-101584` &lt;chr&gt;, `101732-101732` &lt;chr&gt;, `101016-101016` &lt;chr&gt;, #&gt; # `101708-101708` &lt;chr&gt;, `101730-101730` &lt;chr&gt;, `101582-101582` &lt;chr&gt;, #&gt; # `101731-101731` &lt;chr&gt;, `101809-101809` &lt;chr&gt;, `101653-101653` &lt;chr&gt;, #&gt; # `101652-101652` &lt;chr&gt;, `101806-101806` &lt;chr&gt;, `101807-101807` &lt;chr&gt;, #&gt; # `101808-101808` &lt;chr&gt;, `101810-101810` &lt;chr&gt;, `101811-101811` &lt;chr&gt;, #&gt; # `101812-101812` &lt;chr&gt;, `101813-101813` &lt;chr&gt;, `101814-101814` &lt;chr&gt;, #&gt; # `101957-101957` &lt;chr&gt;, `101958-101958` &lt;chr&gt;, `100986-100986` &lt;chr&gt;, #&gt; # `100987-100987` &lt;chr&gt;, `101897-101897` &lt;chr&gt;, `102071-102071` &lt;chr&gt;, #&gt; # `102106-102106` &lt;chr&gt;, `101040-101040` &lt;chr&gt;, `101167-101167` &lt;chr&gt;, #&gt; # `101041-101041` &lt;chr&gt;, `101042-101042` &lt;chr&gt;, `101168-101168` &lt;chr&gt;, #&gt; # `101898-101898` &lt;chr&gt;, `102070-102070` &lt;chr&gt;, `102111-102111` &lt;chr&gt;, #&gt; # `100988-100988` &lt;chr&gt;, `101896-101896` &lt;chr&gt;, `102110-102110` &lt;chr&gt;, #&gt; # `102620-102620` &lt;chr&gt;, `102621-102621` &lt;chr&gt;, `102947-102947` &lt;chr&gt;, #&gt; # `102948-102948` &lt;chr&gt;, `103089-103089` &lt;chr&gt;, `102693-102693` &lt;chr&gt;, #&gt; # `102694-102694` &lt;chr&gt;, `102949-102949` &lt;chr&gt;, `102622-102622` &lt;chr&gt;, #&gt; # `102623-102623` &lt;chr&gt;, `102624-102624` &lt;chr&gt;, `102722-102722` &lt;chr&gt;, #&gt; # `102712-102712` &lt;chr&gt;, `103339-103339` &lt;chr&gt;, `103124-103124` &lt;chr&gt;, #&gt; # `103161-103161` &lt;chr&gt;, `103125-103125` &lt;chr&gt;, `103171-103171` &lt;chr&gt;, #&gt; # `103338-103338` &lt;chr&gt;, `103372-103372` &lt;chr&gt;, `103193-103193` &lt;chr&gt;, #&gt; # `100195-100195` &lt;chr&gt;, `100194-100194` &lt;chr&gt;, `101667-101667` &lt;chr&gt;, #&gt; # `101137-101137` &lt;chr&gt;, `101291-101291` &lt;chr&gt;, `101292-101292` &lt;chr&gt;, #&gt; # `101666-101666` &lt;chr&gt;, `32222-32222` &lt;chr&gt;, `32049-32049` &lt;chr&gt;, #&gt; # `32050-32050` &lt;chr&gt;, `32411-32411` &lt;chr&gt;, `32221-32221` &lt;chr&gt;, #&gt; # `100147-100147` &lt;chr&gt;, `100149-100149` &lt;chr&gt;, `100243-100243` &lt;chr&gt;, #&gt; # `100290-100290` &lt;chr&gt;, `100753-100753` &lt;chr&gt;, `100754-100754` &lt;chr&gt;, #&gt; # `101377-101377` &lt;chr&gt;, `101426-101426` &lt;chr&gt;, `101435-101435` &lt;chr&gt;, #&gt; # `101523-101523` &lt;chr&gt;, `101877-101877` &lt;chr&gt;, `100043-100043` &lt;chr&gt;, #&gt; # `100044-100044` &lt;chr&gt;, `100148-100148` &lt;chr&gt;, `100292-100292` &lt;chr&gt;, #&gt; # `101381-101381` &lt;chr&gt;, `101393-101393` &lt;chr&gt;, ... 2.3 Interval manipulations valr implements several methods for manipulating sets of intervals. Some methods operate on a single set of intervals, while others compare two sets of intervals. Many methods the same name as the corresponding BEDtool, and some commonly used BEDtools are implemented as dplyr pipes (e.g., see the group_by section). All methods accept one or more sets of x and y intervals, which must either be created using the read methods, or have chrom, start and end columns. 2.3.1 Single set operations These methods operate on a single set of intervals: bed_sort(): order intervals bed_cluster(): Cluster (but don’t merge) overlapping/nearby intervals. bed_complement(): extract intervals not represented by an interval file. bed_merge(): combine overlapping and nearby intervals into a single interval. bed_flank(): Generate new flanking intervals bed_slop(): Expand the size of input intervals bed_shift(): Shift the coordinates of an input set, bounded by a genome 2.3.1.1 Sort bed_sort orders intervals based on a specification. is_sorted asks whether a tbl is already sorted. x &lt;- bed_random(genome) is_sorted(x) #&gt; [1] FALSE y &lt;- bed_sort(x) y #&gt; # A tibble: 1,000,000 × 3 #&gt; chrom start end #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 chr1 1118 2118 #&gt; 2 chr1 7737 8737 #&gt; 3 chr1 14104 15104 #&gt; 4 chr1 18658 19658 #&gt; 5 chr1 19850 20850 #&gt; 6 chr1 21419 22419 #&gt; # ... with 1e+06 more rows is_sorted(y) #&gt; [1] TRUE 2.3.1.2 Cluster bed_cluster identifies clustered intervals based on a distance specification and assigns them a unique .id. x &lt;- bed_random(genome) y &lt;- bed_cluster(x, max_dist = 1000) y #&gt; # A tibble: 1,000,000 × 4 #&gt; chrom start end .id #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 chr2 178948946 178949946 57787 #&gt; 2 chr7 78418140 78419140 25450 #&gt; 3 chrY 45020975 45021975 14385 #&gt; 4 chr6 118330682 118331682 38328 #&gt; 5 chr5 35717390 35718390 11465 #&gt; 6 chr8 14300540 14301540 4673 #&gt; # ... with 1e+06 more rows 2.3.1.3 Complement bed_complement identifies intervals in a genome that are not covered by an input. x &lt;- bed_random(genome) bed_complement(x, genome) #&gt; # A tibble: 724,132 × 3 #&gt; chrom start end #&gt; &lt;fctr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 chr1 1 2679 #&gt; 2 chr1 3679 8089 #&gt; 3 chr1 9089 15343 #&gt; 4 chr1 17445 20050 #&gt; 5 chr1 21050 27278 #&gt; 6 chr1 28335 28448 #&gt; # ... with 7.241e+05 more rows 2.3.1.4 Merge bed_merge identifies overlapping intervals and reports new merged ones. is_merged asks whether a tbl is already merged. Values from merged intervals can be reported using name / value pairs. n &lt;- 1e6 x &lt;- bed_random(genome, n = n) is_merged(x) #&gt; [1] FALSE ## add some signal x &lt;- x %&gt;% mutate(signal = runif(n)) bed_merge(x, maxs = max(signal)) #&gt; # A tibble: 723,414 × 4 #&gt; chrom start end maxs #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 chr1 1995 3574 0.61656 #&gt; 2 chr1 5752 6752 0.00495 #&gt; 3 chr1 7414 9964 0.91620 #&gt; 4 chr1 16437 17637 0.81356 #&gt; 5 chr1 20780 21780 0.32964 #&gt; 6 chr1 24767 25767 0.12209 #&gt; # ... with 7.234e+05 more rows 2.3.1.5 Flank bed_flank creates new intervals that flank – but do not contain – the input intervals. bed_flank(x, genome, both = 100) 2.3.1.6 Slop bed_slop pads input intervals based on a specification bed_slop(x, genome, both = 100) 2.3.1.7 Shift bed_shift adjusts coordinates toward start or end by a defined size. Intervals created out of bounds are removed, or trimmed. bed_shift(x, genome, size = 100) #&gt; # A tibble: 1,000,000 × 4 #&gt; chrom start end signal #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 chr18 5.00e+07 5.00e+07 0.0074 #&gt; 2 chr19 3.95e+07 3.95e+07 0.4664 #&gt; 3 chr4 1.18e+08 1.18e+08 0.4978 #&gt; 4 chr2 4.32e+07 4.32e+07 0.2898 #&gt; 5 chr9 6.83e+07 6.83e+07 0.7329 #&gt; 6 chr3 1.22e+08 1.22e+08 0.7725 #&gt; # ... with 1e+06 more rows 2.3.1.8 Interval spacing Interval spacing is easily computed using dplyr. Overlapping intervals must first be merged. Spacing for the first interval of each chromosome is undefined. x &lt;- bed_random(genome) x &lt;- bed_merge(x) x %&gt;% group_by(chrom) %&gt;% mutate(.spacing = start - lag(end)) #&gt; Source: local data frame [724,197 x 4] #&gt; Groups: chrom [25] #&gt; #&gt; chrom start end .spacing #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 chr1 2040 3040 NA #&gt; 2 chr1 6963 7963 3923 #&gt; 3 chr1 13766 14766 5803 #&gt; 4 chr1 16192 17514 1426 #&gt; 5 chr1 18080 19190 566 #&gt; 6 chr1 19582 20582 392 #&gt; # ... with 7.242e+05 more rows 2.3.2 Multiple set operations These methods compare two sets of intervals: bed_intersect(): find overlapping intervals bed_map(): apply a function to selected columns for overlapping intervals bed_subtract(): Remove intervals based on overlaps between two files bed_window(): Find overlapping intervals within a window bed_closest(): find the closest intervals independent of overlaps 2.3.2.1 Intersection bed_intersect is implemented using an interval tree in Rcpp. Column names in the result have .x and .y suffixes, and an .overlap column contains the size of the intersection (values of 0 indicate book-ended, or touching intervals). See the benchmarks section for timing. Though bed_intersect is pretty fast already, we intend to further improve upon this by parallization with RcppParallel. # intersect two sets of 1e6 intervals from hg19 x &lt;- bed_random(genome) y &lt;- bed_random(genome) bed_intersect(x, y) #&gt; # A tibble: 646,445 × 6 #&gt; chrom start.x end.x start.y end.y .overlap #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 chr1 3450 4450 2900 3900 450 #&gt; 2 chr1 10287 11287 11286 12286 1 #&gt; 3 chr1 10542 11542 11286 12286 256 #&gt; 4 chr1 10604 11604 11286 12286 318 #&gt; 5 chr1 26866 27866 26937 27937 929 #&gt; 6 chr1 37711 38711 38301 39301 410 #&gt; # ... with 6.464e+05 more rows # A records with no overlaps (i.e., `-v`) bed_intersect(x, y, invert = TRUE) #&gt; Source: local data frame [524,327 x 3] #&gt; Groups: chrom [25] #&gt; #&gt; chrom start end #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 chrY 59359682 59360682 #&gt; 2 chrY 59343718 59344718 #&gt; 3 chrY 59339334 59340334 #&gt; 4 chrY 59285946 59286946 #&gt; 5 chrY 59280348 59281348 #&gt; 6 chrY 59256175 59257175 #&gt; # ... with 5.243e+05 more rows One can achieve behaviour similar to BEDtools by combining bed_intersect with dplyr tools. # `x` records with overlaps (i.e., `-wa`) bed_intersect(x, y) %&gt;% select(chrom, start = start.x, end = end.x) #&gt; # A tibble: 646,445 × 3 #&gt; chrom start end #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 chr1 3450 4450 #&gt; 2 chr1 10287 11287 #&gt; 3 chr1 10542 11542 #&gt; 4 chr1 10604 11604 #&gt; 5 chr1 26866 27866 #&gt; 6 chr1 37711 38711 #&gt; # ... with 6.464e+05 more rows # `y` records with overlaps (i.e., `-wb`) bed_intersect(x, y) %&gt;% select(chrom, start = start.y, end = end.y) #&gt; # A tibble: 646,445 × 3 #&gt; chrom start end #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 chr1 2900 3900 #&gt; 2 chr1 11286 12286 #&gt; 3 chr1 11286 12286 #&gt; 4 chr1 11286 12286 #&gt; 5 chr1 26937 27937 #&gt; 6 chr1 38301 39301 #&gt; # ... with 6.464e+05 more rows # Unique records in `x` (i.e., `-u`) bed_intersect(x, y) %&gt;% select(chrom, start = start.x, end = end.x) %&gt;% unique() #&gt; # A tibble: 475,588 × 3 #&gt; chrom start end #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 chr1 3450 4450 #&gt; 2 chr1 10287 11287 #&gt; 3 chr1 10542 11542 #&gt; 4 chr1 10604 11604 #&gt; 5 chr1 26866 27866 #&gt; 6 chr1 37711 38711 #&gt; # ... with 4.756e+05 more rows # Count `y` intervals that intersect each `x` interval bed_intersect(x, y) %&gt;% group_by(chrom, start.x, end.x) %&gt;% summarize(count = n()) #&gt; Source: local data frame [475,588 x 4] #&gt; Groups: chrom, start.x [?] #&gt; #&gt; chrom start.x end.x count #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 chr1 3450 4450 1 #&gt; 2 chr1 10287 11287 1 #&gt; 3 chr1 10542 11542 1 #&gt; 4 chr1 10604 11604 1 #&gt; 5 chr1 26866 27866 1 #&gt; 6 chr1 37711 38711 1 #&gt; # ... with 4.756e+05 more rows 2.3.2.2 Map bed_map maps signals onto intervals. Summary statistics for mapped signals can be specific using NSE with name / value pairs. bedfile &lt;- system.file(&#39;extdata&#39;, &#39;genes.hg19.chr22.bed.gz&#39;, package = &#39;valr&#39;) bgfile &lt;- system.file(&#39;extdata&#39;, &#39;hela.h3k4.chip.bg.gz&#39;, package = &#39;valr&#39;) x &lt;- read_bed(bedfile, n_fields = 6) y &lt;- read_bedgraph(bgfile) bed_map(x, y, means = mean(value.y), sds = sd(value.y)) #&gt; # A tibble: 591 × 5 #&gt; chrom start.x end.x means sds #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 chr22 16150259 16193004 7.91 7.571 #&gt; 2 chr22 16162065 16172265 1.00 NA #&gt; 3 chr22 16256331 16287937 1.00 0.000 #&gt; 4 chr22 17071647 17073700 1.00 0.000 #&gt; 5 chr22 17082800 17129720 1.12 0.327 #&gt; 6 chr22 17134598 17156430 1.29 0.588 #&gt; # ... with 585 more rows 2.3.2.3 Subtract bed_substract() removes x intervals that intersect with y. x &lt;- bed_random(genome) y &lt;- bed_random(genome) bed_subtract(x, y) #&gt; # A tibble: 723,809 × 3 #&gt; chrom start end #&gt; &lt;fctr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 chr1 10135 10651 #&gt; 2 chr1 11714 12534 #&gt; 3 chr1 14900 16764 #&gt; 4 chr1 20598 21626 #&gt; 5 chr1 25225 25436 #&gt; 6 chr1 29968 30968 #&gt; # ... with 7.238e+05 more rows 2.3.2.4 Window bed_window() identifies y intervals that intersect an expanded window of x intervals. x &lt;- bed_random(genome, n = 100) y &lt;- bed_random(genome, n = 100) # a few intersections bed_intersect(x, y) #&gt; # A tibble: 0 × 6 #&gt; # ... with 6 variables: chrom &lt;chr&gt;, start.x &lt;int&gt;, end.x &lt;int&gt;, #&gt; # start.y &lt;int&gt;, end.y &lt;int&gt;, .overlap &lt;int&gt; # can be expanded by casting a wider net bed_window(x, y, genome, both = 1e6) #&gt; # A tibble: 6 × 6 #&gt; chrom start.x end.x start.y end.y .overlap #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 chr10 5084295 5085295 5179694 5180694 1000 #&gt; 2 chr11 2857611 2858611 2712061 2713061 1000 #&gt; 3 chr13 103725094 103726094 104516400 104517400 1000 #&gt; 4 chr15 38779660 38780660 39050011 39051011 1000 #&gt; 5 chr3 141235271 141236271 141863947 141864947 1000 #&gt; 6 chr8 49949992 49950992 50924834 50925834 1000 2.3.2.5 Closest bed_closest() identifies y intervals that are closest to x. x &lt;- bed_random(genome, n = 100) y &lt;- bed_random(genome, n = 100) bed_closest(x, y) #&gt; # A tibble: 99 × 7 #&gt; chrom start.x end.x start.y end.y .overlap .distance #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 chr1 4921725 4922725 69226270 69227270 0 64303545 #&gt; 2 chr1 18521748 18522748 69226270 69227270 0 50703522 #&gt; 3 chr1 18739282 18740282 69226270 69227270 0 50485988 #&gt; 4 chr1 56436890 56437890 69226270 69227270 0 12788380 #&gt; 5 chr1 108417647 108418647 136064461 136065461 0 27645814 #&gt; 6 chr1 118151382 118152382 136064461 136065461 0 17912079 #&gt; # ... with 93 more rows 2.3.3 Randomzing intervals valr provides methods for creating new random intervals or permutations of existing intervals: bed_random generates random intervals from an input genome. bed_shuffle shuffles coordinates given a set of input intervals. Random sampling of input intervals is done with dplyr. 2.3.3.1 Random bed_random generates random intervals from an input genome. The numbers of intervals from each chrom are proporitional to each chrom size. x &lt;- bed_random(genome, n = 1e6, length = 1e3) x #&gt; # A tibble: 1,000,000 × 3 #&gt; chrom start end #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 chr2 158609707 158610707 #&gt; 2 chrY 40570006 40571006 #&gt; 3 chr7 113761802 113762802 #&gt; 4 chr5 15069746 15070746 #&gt; 5 chr2 193127129 193128129 #&gt; 6 chr19 52909745 52910745 #&gt; # ... with 1e+06 more rows # numbers of sampled intervals are proportional to chrom size group_by(x, chrom) %&gt;% summarize(n = n()) %&gt;% arrange(desc(n)) #&gt; # A tibble: 25 × 2 #&gt; chrom n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 chr1 80424 #&gt; 2 chr2 78429 #&gt; 3 chr3 64212 #&gt; 4 chr4 62340 #&gt; 5 chr5 58001 #&gt; 6 chr6 55008 #&gt; # ... with 19 more rows 2.3.3.2 Sample Sampling can be done using dplyr: x &lt;- bed_random(genome) # sample by number sample_n(x, 1e3, replace = FALSE) #&gt; # A tibble: 1,000 × 3 #&gt; chrom start end #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 chr2 212289263 212290263 #&gt; 2 chr5 86119719 86120719 #&gt; 3 chr8 140585044 140586044 #&gt; 4 chr4 36362470 36363470 #&gt; 5 chr4 147834818 147835818 #&gt; 6 chr9 14044797 14045797 #&gt; # ... with 994 more rows # or fraction sample_frac(x, 0.1, replace = FALSE) #&gt; # A tibble: 100,000 × 3 #&gt; chrom start end #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 chr5 13154911 13155911 #&gt; 2 chr3 43168654 43169654 #&gt; 3 chr18 61254512 61255512 #&gt; 4 chr6 47738235 47739235 #&gt; 5 chrY 38617492 38618492 #&gt; 6 chr15 3179031 3180031 #&gt; # ... with 9.999e+04 more rows # or sample intervals within groups group_by(x, chrom) %&gt;% sample_n(1) #&gt; Source: local data frame [25 x 3] #&gt; Groups: chrom [25] #&gt; #&gt; chrom start end #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 chr1 105747789 105748789 #&gt; 2 chr10 49907928 49908928 #&gt; 3 chr11 62787101 62788101 #&gt; 4 chr12 45964817 45965817 #&gt; 5 chr13 60548688 60549688 #&gt; 6 chr14 34531511 34532511 #&gt; # ... with 19 more rows 2.3.3.3 Shuffle bed_shuffle shuffles input intervals. Interval sizes are equal in the input and output. y &lt;- bed_shuffle(x) any(x$start == y$start) all(x$end - x$start == y$end - y$start) 2.3.4 Other topics 2.3.4.1 Grouping related intervals The group_by operation from dplyr serves a similar purpose to BEDtools groupby, and can be combined with dplyr::summarize to calculate summary statistics from groups. x &lt;- bed_random(genome) y &lt;- bed_random(genome) bed_intersect(x, y) %&gt;% group_by(chrom) %&gt;% summarize(overlap.total = sum(.overlap)) #&gt; # A tibble: 25 × 2 #&gt; chrom overlap.total #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 chr1 26156419 #&gt; 2 chr10 13838133 #&gt; 3 chr11 14005918 #&gt; 4 chr12 14216949 #&gt; 5 chr13 11850603 #&gt; 6 chr14 11098228 #&gt; # ... with 19 more rows 2.3.5 Interval Statistics valr provides several methods to assess statistical properties of interval sets including: bed_fisher(): measure overlap significance of two sets of intervals. bed_absdist(): XXX bed_reldist(): quantify relative distances between query intervals and closest reference intervals bed_jaccard(): quantify extent of overlap between two sets of intervals bed_projection(): XXX Several of these methods were described in the Genometricorr software package. 2.3.5.1 Fisher’s test The Fisher’s test assesses whether two sets of intervals are drawn from the same background genome. x &lt;- bed_random(genome) y &lt;- bed_random(genome) bed_fisher(x, y, genome) #&gt; estimate p.value conf.low conf.high method #&gt; 1 2.38 0 2.36 2.39 Fisher&#39;s Exact Test for Count Data #&gt; alternative #&gt; 1 two.sided 2.3.5.2 Absolute distance bed_absdist() - XXX 2.3.5.3 Relative distance bed_reldist() computes the relative distance between a query interval and the two closest reference intervals. The relative distance can range between [0,0.5]. If the overall distribution of distances is biased toward zero, then the query and reference intervals tend to be closer in space (17). By default a summary with the frequency of each relative distance is reported. x &lt;- bed_random(genome) y &lt;- bed_random(genome) bed_reldist(x, y) #&gt; # A tibble: 51 × 4 #&gt; reldist counts total freq #&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 0.00 19813 999955 0.0198 #&gt; 2 0.01 20140 999955 0.0201 #&gt; 3 0.02 19658 999955 0.0197 #&gt; 4 0.03 19790 999955 0.0198 #&gt; 5 0.04 20032 999955 0.0200 #&gt; 6 0.05 20389 999955 0.0204 #&gt; # ... with 45 more rows 2.3.5.4 Jaccard similarity bed_jaccard() quantifies the extent of overlap between to sets of intervals. The Jaccard statistic takes values of [0,1] and is measured as: \\[ J(x,y) = \\frac{\\mid x \\bigcap y \\mid} {\\mid x \\bigcup y \\mid} = \\frac{\\mid x \\bigcap y \\mid} {\\mid x \\mid + \\mid y \\mid - \\mid x \\bigcap y \\mid} \\] x &lt;- bed_random(genome) y &lt;- bed_random(genome) bed_jaccard(x, y) #&gt; # A tibble: 1 × 4 #&gt; len_i len_u jaccard n #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 322727018 2000000000 0.192 645541 2.3.5.5 Projection bed_projection() TBD 2.3.6 Benchmarks # two sets of 1e6 random 1 kb intervals from hg19 x &lt;- bed_random(genome) y &lt;- bed_random(genome) library(microbenchmark) microbenchmark( bed_random(genome), bed_closest(x, y), bed_intersect(x, y), bed_merge(x), bed_subtract(x, y), bed_complement(x, genome), times = 1, unit = &#39;s&#39; ) #&gt; Unit: seconds #&gt; expr min lq mean median uq max neval #&gt; bed_random(genome) 0.232 0.232 0.232 0.232 0.232 0.232 1 #&gt; bed_closest(x, y) 8.905 8.905 8.905 8.905 8.905 8.905 1 #&gt; bed_intersect(x, y) 3.106 3.106 3.106 3.106 3.106 3.106 1 #&gt; bed_merge(x) 4.476 4.476 4.476 4.476 4.476 4.476 1 #&gt; bed_subtract(x, y) 2.084 2.084 2.084 2.084 2.084 2.084 1 #&gt; bed_complement(x, genome) 4.211 4.211 4.211 4.211 4.211 4.211 1 "],
["demos.html", "Chapter 3 Demonstrations 3.1 DNase I Example.", " Chapter 3 Demonstrations 3.1 DNase I Example. Here’s the DNase I example. "],
["benchmarks.html", "Chapter 4 Benchmarks 4.1 Intersection 4.2 Closest 4.3 Merge 4.4 Subtract", " Chapter 4 Benchmarks Here we consider the performance of valr with respect to other R packages. library(valr) library(bedr) #&gt; #&gt; #&gt; ###################### #&gt; #### bedr v1.0.3 #### #&gt; ###################### #&gt; #&gt; checking binary availability... #&gt; * Checking path for bedtools... FAIL #&gt; * Checking path for bedops... FAIL #&gt; * Checking path for tabix... FAIL #&gt; tests and examples will be skipped on R CMD check if binaries are missing library(IRanges) #&gt; Loading required package: methods #&gt; Loading required package: BiocGenerics #&gt; Loading required package: parallel #&gt; #&gt; Attaching package: &#39;BiocGenerics&#39; #&gt; The following objects are masked from &#39;package:parallel&#39;: #&gt; #&gt; clusterApply, clusterApplyLB, clusterCall, clusterEvalQ, #&gt; clusterExport, clusterMap, parApply, parCapply, parLapply, #&gt; parLapplyLB, parRapply, parSapply, parSapplyLB #&gt; The following objects are masked from &#39;package:dplyr&#39;: #&gt; #&gt; combine, intersect, setdiff, union #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; IQR, mad, xtabs #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; anyDuplicated, append, as.data.frame, cbind, colnames, #&gt; do.call, duplicated, eval, evalq, Filter, Find, get, grep, #&gt; grepl, intersect, is.unsorted, lapply, lengths, Map, mapply, #&gt; match, mget, order, paste, pmax, pmax.int, pmin, pmin.int, #&gt; Position, rank, rbind, Reduce, rownames, sapply, setdiff, #&gt; sort, table, tapply, union, unique, unsplit #&gt; Loading required package: S4Vectors #&gt; Loading required package: stats4 #&gt; #&gt; Attaching package: &#39;S4Vectors&#39; #&gt; The following objects are masked from &#39;package:dplyr&#39;: #&gt; #&gt; first, rename #&gt; The following objects are masked from &#39;package:valr&#39;: #&gt; #&gt; first, values #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; colMeans, colSums, expand.grid, rowMeans, rowSums #&gt; #&gt; Attaching package: &#39;IRanges&#39; #&gt; The following objects are masked from &#39;package:dplyr&#39;: #&gt; #&gt; collapse, desc, regroup, slice library(GenomicRanges) #&gt; Loading required package: GenomeInfoDb library(dplyr) library(microbenchmark) genome &lt;- read_genome(system.file(&#39;extdata&#39;, &#39;hg19.chrom.sizes.gz&#39;, package = &#39;valr&#39;)) x &lt;- bed_random(genome) y &lt;- bed_random(genome) 4.1 Intersection 4.2 Closest 4.3 Merge 4.4 Subtract "]
]
